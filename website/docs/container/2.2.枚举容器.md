## 2.2.1. 基本使用

我们可以使用 `Containers.forEnum` 方法基于枚举类快速配置一个枚举数据源：

```java
@Getter
@RequiredArgsConstructor
private enum Num {
    ONE(1, "one"),
    TWO(2, "two");
    private final int code;
    private final String value;
}

// 使用 Containers.forEnum 方法构建容器
// 容器缓存的数据为： {1 = ONE}, {2 = TWO}
Container<String> container = Containers.forEnum("num", Num.class, Enum::getCode); // 指定 key 值为 code
```

使用该容器后，可以通过键值（code）从容器中获取对应的枚举实例。

或者，也可以通过建造者构建一个枚举容器：

~~~java
Container<Object> container = EnumContainerBuilder.of(AnnotatedEnum.class)
    .namespace("test") // 指定命名空间
    .key("value") // 指定提供key值的属性
    .value("key") // 指定提供value值的属性
    .build();
~~~

相比起通过静态工厂方法构建，建造者提供更多的配置项。

## 2.2.2. 可选注解

除了普通枚举外，我们还可以通过 `@ContainerEnum` 注解来进一步定义容器的具体信息：

```java
@ContainerEnum(namespace = "AnnotatedEnum", key = "key", value = "value")
@Getter
@RequiredArgsConstructor
private enum Num {
    ONE(1, "one"),
    TWO(2, "two");
    private final int key;
    private final String value;
}

// 使用 Containers.forEnum 方法构建容器
// 容器缓存的数据为： {1 = "one"}, {2 = "two"}
Container<String> container = Containers.forEnum(Num.class, new SimpleAnnotationFinder());
```

在这个示例中，我们通过 `@ContainerEnum` 注解配置了一些额外的信息：

- `namespace`：命名空间为 "AnnotatedEnum"，如果不配置，默认为枚举类的 `Class.getSimpleName()`；
- `key`：数据源对象的 key 值取枚举项的 key 字段值，如果不配置，默认为枚举的 `Enum.name()`；
- `value`：数据源对象为枚举项的 value 字段值，如果不配置，默认为枚举项本身。

:::tip

在 springboot 中，我们也可以在配置文件中直接扫描路径下的所有枚举类，然后将其注册为容器。

:::

## 2.2.3.枚举装配

由于基于枚举的填充操作比较常见，`crane4j` 提供了 `@AssembleEnum` 注解，用于快速声明此类操作。下面是一个示例：

```java
@RequiredArgsConstructor
@Data
private static class Foo {
    @AssembleEnum(type = Gender.class, enumKey = "code", enumValue = "cnName", ref = "cnName", sort = 1) // 不遵照 @ContainerEnum 的配置
    @AssembleEnum(type = Gender.class, ref = "gender", sort = 2, useContainerEnum = true) // 遵照 @ContainerEnum 的配置
    private final Integer id;
    private String cnName;
    private Gender gender;
}

@ContainerEnum(namespace = "gender", key = "code")
@Getter
@RequiredArgsConstructor
private enum Gender {
    FEMALE(0, "女", "female"), MALE(1, "男", "male");
    private final Integer code;
    private final String cnName;
    private final String enName;
}
```

在上述示例中，我们定义了一个枚举类 `Gender`，它有 `code`、`cnName` 和 `enName` 三个字段。然后，我们在 `Foo` 类中声明了两个基于 `id` 的装配操作：

1. 第一个装配操作忽略了枚举上的 `@ContainerEnum` 配置。它根据 `Foo.id` 找到对应的 `Gender.code` 枚举项，并将 `Gender.cnName` 映射到 `Foo.cnName` 字段；
2. 第二个装配操作遵循了枚举上的 `@ContainerEnum` 配置。它根据 `Foo.id` 找到对应的 `Gender.code` 枚举项，并直接将该枚举项映射到 `Foo.gender` 字段；

相比使用 `@Assemble` 注解，`@AssembleEnum` 简化了声明枚举容器的步骤。具体的内容可以参考后文的 "**声明装配操作**" 与 "**配置字段映射**" 一节。

